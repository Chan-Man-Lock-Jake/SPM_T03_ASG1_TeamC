import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
import { getFirestore, addDoc, collection, setDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

const firebaseConfig = {
    apiKey: "AIzaSyCvsupITjCXYnyJ5taUTfgKaTr4ICuZmI4",
    authDomain: "auth-e1f14.firebaseapp.com",
    databaseURL: "https://auth-e1f14-default-rtdb.firebaseio.com",
    projectId: "auth-e1f14",
    storageBucket: "auth-e1f14.appspot.com",
    messagingSenderId: "744589697016",
    appId: "1:744589697016:web:47a44ec6954e8bfd2bc800d"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

const profitElement = document.getElementById('profit');
const upkeepElement = document.getElementById('upkeep');
const incomeElement = document.getElementById('income');
const counterElement = document.getElementById('counter'); 
const scoreElement = document.getElementById('score');
const turnElement = document.getElementById('turn');
const buildingOptionsContainer = document.getElementById('building-options');

// Starting stats
let profit = 0;
let upkeep = 0;
let income = 0;
let counter = 0;
let score = 0;
let turn = 0;
let grid = []

let firstBuilding = true;
let selectedCell = null;

// R = Residential
// I = Industry
// C = Commercial
// O = Park
// * = Road
const buildingTypes = ['R', 'I', 'C', 'O', '*'];

//BreakPoint ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function handleDragStart(e) {
    e.dataTransfer.setData('text/plain', e.target.textContent.trim());
}

function handleDragOver(e) {
    e.preventDefault();
    //e.target.style.backgroundColor = 'red';
}

function handleDragDrop(e) {
    e.preventDefault();

    const building = e.dataTransfer.getData('text/plain');
    const row = parseInt(e.target.dataset.row);
    const col = parseInt(e.target.dataset.col);
    if (checkBuilding(row, col)) {
        addBuilding(row, col, building);
        generateBuilding();
        turn++
        turnElement.textContent = turn;
    } else {
        alert("Invalid placement! Buildings must be placed orthogonally to existing buildings.");
    }
}

function handleCellClick(e) {
    const row = parseInt(e.target.dataset.row);
    const col = parseInt(e.target.dataset.col);

    document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('glow'));

    if (grid[row][col].dataset.building) {
        selectedCell = { row, col };
        demolishButton.disabled = false;

        e.target.classList.add('glow');

    } else {
        selectedCell = null;
        demolishButton.disabled = true;
    }
}

function createBoard(rows, cols) {
    const gameBoard = document.getElementById('game-board');
    if(gameBoard) {
        gameBoard.innerHTML = '';
    }
    gameBoard.style.gridTemplateColumns = `repeat(${cols}, 40px)`;
    gameBoard.style.gridTemplateRows = `repeat(${rows}, 40px)`;
    const grid = [];
    for (let row = 0; row < rows; row++) {
        const rowArr = [];
        for (let col = 0; col < cols; col++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.addEventListener('dragover', handleDragOver);
            cell.addEventListener('drop', handleDragDrop);
            cell.addEventListener('click', handleCellClick);
            gameBoard.appendChild(cell);
            rowArr.push(cell);
        }
        grid.push(rowArr);
    }
    return grid;
}

function countIncome() {
    income = 0; // Reset income each turn

    grid.forEach (row => {
        row.forEach(cell => {

            // Coins can be generated by :
            // 1. R - 1 coin per turn
            // 2. I - 2 coins per turn
            // 3. C - 3 coins per turn

            if (cell.dataset.building === 'R') {
                income += 1; 
            } else if (cell.dataset.building === 'I') {
                income += 2; 
            } else if (cell.dataset.building === 'C') {
                income += 3; 
            }
        });
    });
    incomeElement.textContent = income;
}

function updateProfit() {
    profit = income - upkeep;
    profitElement.textContent = profit;
    upkeepElement.textContent = upkeep;
    console.log(`Upkeep: ${upkeep}, Income: ${income}, Profit: ${profit}, Counter: ${counter}, Score: ${totalScore()}`);

    if (profit < 0) {
        counter += 1;
        if( counter === 20) {
            alert("Game Over! You've had 20 consecutive losses.");
            endGame();
        }
    } else {
        // Reset counter when there is profit
        counter = 0; 
    }
    counterElement.textContent = counter; 
}

function countUpkeep() {
    upkeep = 0; // Reset upkeep each turn
    grid.forEach (row => {
        row.forEach(cell =>  {
            if (cell.dataset.building) {
                switch (cell.dataset.building) {
                    case 'R':
                        upkeep += 1;
                        break;
                    case 'I':
                        upkeep += 1;
                        break;
                    case 'C' :
                        upkeep += 2;
                        break;
                    case 'O':
                        upkeep += 1;
                        break;
                    case '*':
                        upkeep += 1;
                        break;
                }
            }
        });
    });
    updateProfit();
}

function countScore(type, neighbors, row, col) {
    //let score = 0;
    switch (type) {
        case 'R':
            score = countResidential(neighbors);
            break;
        case 'I':
            score += 1;
            break;
        case 'C' :
            score = countCommercial(neighbors);
            break;
        case 'O':
            score = countPark(neighbors);
            break;
        case '*':
            score = countRoad(neighbors);
            break;
    }   
    grid[row][col].dataset.score = score;
}

function countResidential(neighbor) {
    let score = 0;
    for (let e = 0; e < 4; e++) {
        if (typeof neighbor[e] === 'string') {
            continue;
        }
        if (neighbor[e].dataset.building === 'I') {
            score += 1;
            break;
        } else if (neighbor[e].dataset.building === 'R' || neighbor[e].dataset.building === 'C') {
            score += 1;
        } else if (neighbor[e].dataset.building === 'O') {
            score += 2;
        }
    }
    return score;
}

function countCommercial(neighbor) {
    let score = 0;
    for (let e = 0; e < 4; e++) {
        if (typeof neighbor[e] === 'string') {
            continue;
        }
        if (neighbor[e].dataset.building === 'C') {
            score += 1;
        }
    }
    return score;
}

function countPark(neighbor) {
    let score = 0;
    for (let e = 0; e < 4; e++) {
        if (typeof neighbor[e] === 'string') {
            continue;
        }
        if (neighbor[e].dataset.building === 'O') {
            score += 1;
        }
    }
    return score;
}

function countRoad(neighbor) {
    let score = 0;
    for (let e = 0; e < 4; e++) {
        if (typeof neighbor[e] === 'string') {
            continue;
        }
        if (neighbor[e].dataset.building === '*' && (e === 1 || e === 2)) {
            score += 1;
            break;
        }
    }
    console.log(score, "ROAD")
    return score;

}

function totalScore() {
    let totalScore = 0;
    grid.forEach(row => {
        row.forEach(cell => {
            const score = parseInt(cell.dataset.score, 10);
            if (!isNaN(score)) {
                totalScore += score;
            }
        });
    });
    console.log('Total Score: ',totalScore);
    return totalScore;
}

// Place building at the given row & col
function addBuilding(row, col, type) {
    const cell = grid[row][col];
    cell.innerHTML = `${type}`;
    cell.dataset.building = type;
    cell.dataset.score = score;
    cell.classList.add('building');

    // Neighbors of the building placed
    let neighbors = [
        row != 0 ? grid[row - 1][col] : "Top Border", //TOP
        col != 0 ? grid[row][col - 1] : "Left Border", //LEFT
        col < grid.length - 1 ? grid[row][col + 1] : "Right Border", //RIGHT
        row < grid.length - 1 ? grid[row + 1][col] : "Bottom Border" //BOTTOM
    ];

    for (let i = 0; i < 4; i++) {            
        if (typeof neighbors[i] === 'string') {
            continue;
        }

        const neighborRow = parseInt(neighbors[i].dataset.row);
        const neighborCol = parseInt(neighbors[i].dataset.col);

        let neighbors2 = [
            neighborRow - 1 > 0 ? grid[neighborRow - 1][neighborCol] : "Top Border", //TOP
            neighborCol != 0 ? grid[neighborRow][neighborCol - 1] : "Left Border", //LEFT
            neighborCol < grid.length - 1 ? grid[neighborRow][neighborCol + 1] : "Right Border", //RIGHT
            neighborRow < grid.length - 1 ? grid[neighborRow + 1][neighborCol] : "Bottom Border" //BOTTOM
        ];

    }

    countScore(type, neighbors, row, col);
    countIncome(type, neighbors);
    countUpkeep();
    scoreElement.textContent = totalScore();

    if(isOnBorder(row, col)) {
        expandGrid();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const demolishButton = document.getElementById('demolishButton');
    if (demolishButton) {
        demolishButton.addEventListener('click', demolishBuilding);
    } else {
        console.error('Demolish Button not found');
    }
});

// Remove building at the given row and col
function demolishBuilding() {     
    if (turn === 0) { // Check if it's the first turn
        alert("You cannot demolish buildings during the first turn.");
        return;
    }   
    if (selectedCell) {
        const { row, col } = selectedCell;
        const cell = grid[row][col];
        if (cell.dataset.building) {
            income += 1;
            incomeElement.textContent = income;

            cell.innerHTML = '';
            delete cell.dataset.building ;
            cell.dataset.score = '';
            cell.classList.remove('building');

            countUpkeep();
            scoreElement.textContent = totalScore();
            saveGameState();

            selectedCell = null;
        }
    } else {
        alert("No building to demolish at this location!");
    }
}
function isOnBorder(row, col) {
    const size = grid.length;
    return row === 0 || col === 0 || row === size - 1 || col === size - 1;
}

function expandGrid() {
    const currentSize = grid.length;
    const newSize = currentSize + 10;
    const newGrid = createBoard(newSize, newSize);

    // Copy existing buildings and scores to the center of new grid
    for (let row = 0; row < currentSize; row++) {
        for (let col = 0; col < currentSize; col++) {
            const oldCell = grid[row][col];
            const newCell = newGrid[row + 5][col + 5];

            newCell.innerHTML = oldCell.innerHTML;
            newCell.dataset.building = oldCell.dataset.building;
            newCell.dataset.score = oldCell.dataset.score;
            newCell.classList = oldCell.classList;
        }
    }

    // Update the grid reference
    grid = newGrid;
}


function checkBuilding(row, col) {
    if (firstBuilding) {
        firstBuilding = false;
        return true
    };
    if (grid[row] && grid[row][col] && grid[row][col].textContent !== '') {
        return false;
    }
    const neighbors = [
        { r: row - 1, c: col },
        { r: row + 1, c: col },
        { r: row, c: col - 1 },
        { r: row, c: col + 1 }
    ];
    return neighbors.some(neighbor => {
        return grid[neighbor.r] && grid[neighbor.r][neighbor.c] && grid[neighbor.r][neighbor.c].textContent !== '';
    });
}

function generateBuilding() {
    buildingOptionsContainer.innerHTML = '';
    const option1 = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
    let option2 = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
    while (option2 === option1) {
        option2 = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
    }

    const div1 = document.createElement('div');
    div1.innerHTML = `${option1}`; // Remove image URL
    div1.classList.add('building-option', 'draggable');
    div1.draggable = true;
    div1.addEventListener('dragstart', handleDragStart);

    const div2 = document.createElement('div');
    div2.innerHTML = `${option2}`; // Remove image URL
    div2.classList.add('building-option', 'draggable');
    div2.draggable = true;
    div2.addEventListener('dragstart', handleDragStart);

    buildingOptionsContainer.appendChild(div1)
    buildingOptionsContainer.appendChild(div2);
}

function endGame() {
    alert('Game Over! Click OK to see your final score.');
    
    localStorage.setItem('finalScore', totalScore());
    // Save the game state before redirecting
    saveGameState();

    // Redirect to end-game.html
    window.location.href = 'end-game.html';
    
}

function startGame() {
    profit = 0;
    upkeep = 0;
    income = 0;
    counter = 0;
    score = 0;
    turn = 0;
    grid = createBoard(5, 5);
    profitElement.textContent = profit;
    upkeepElement.textContent = upkeep;
    incomeElement.textContent = income;
    counterElement.textContent = counter;
    scoreElement.textContent = score;
    turnElement.textContent = turn;
    generateBuilding();
}


startGame();

function getUserFromLocalStorage() {
    const user = JSON.parse(localStorage.getItem('user'));
    return user;
}

function saveUserToLocalStorage(user) {
    localStorage.setItem('user', JSON.stringify(user));
}

document.getElementById('saveGameButton').addEventListener('click', async () => {
    const fileName = (prompt("Enter a name for the saved game:") || "").trim();

    if (!fileName) {
        alert("A file name is required to save the game.");
        return;
    }

    const user = getUserFromLocalStorage();

    if (!user) {
        alert("No user authenticated or UID is missing. Please log in.");
        window.location.href = 'index.html';
        return;
    }

    try {
        const gameState = {
            board: JSON.stringify(boardArray), 
            profit: profit,
            upkeep: upkeep,
            income: income,
            counter: counter,
            score: score,
            turn: turn
        };

        console.log("Saving game state:", gameState);

        const savedGameRef = collection(db, "Users", user.uid, "savedGames");
        await addDoc(savedGameRef, {
            name: fileName,
            gameState: gameState
        });

        alert("Game saved successfully!");
    } catch (error) {
        console.error("Error saving game state:", error.message);
        alert("Failed to save game state. Check the console for details.");
    }
});

onAuthStateChanged(auth, (user) => {
    if (user) {
        saveUserToLocalStorage({ uid: user.uid, email: user.email });
    } else {
        localStorage.removeItem('user');
    }
});

document.getElementById('exitGameButton').addEventListener('click', async () => { 
    const userConfirmed = window.confirm("Are you sure? Game progress will not be saved.");

    if (userConfirmed) {
        window.location.href = 'home.html';
    } else {
        console.log("User canceled the exit.");
    }
});